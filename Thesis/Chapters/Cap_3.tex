\chapter{Programmazione del supporto hardware del progetto}\label{cap:Programmazione del supporto hardware del progetto}

\section{Programmazione RaspberryPi}\label{sez:Programmazione RaspberryPi}
\raggedright
Come descritto nella sezione precedente, la "board" usata per il progetto è stata un "RaspberryPi 3b+", che chiaramente  era una "board" datata, dato che da circa un anno era stato rilasciato il "RaspebrryPi 4". Quindi il software disponibile per questi sistemi è stato aggiornato per adattarsi alle nuove caratteristiche e potenzialità, con la conseguenza che i modelli più vecchi non erano più idonei a supportare il software "main line" a causa delle risorse limitate rispetto ai più recenti.\\
Per questo motivo si è pensato (pur utilizzando software "main line") di cercare di risparmiare risorse provando a sostituire il "desktop enviroment" di base, installato con il sistema operativo "Raspbian". In particolare l'intento è stato quello di confrontare le prestazioni tra il "desktop enviroment Pixel" (basato su "LXDE") e di "XFCE".  

\subsection{Installazione del "desktop eviroment XFCE" e delle applicazioni di base}
\raggedright
Dal sito di "\href{https://www.raspberrypi.com/software/operating-systems/}{RaspberryPi}" è stata scaricata l'immagine del sistema operativo "Raspbian" in formato "Lite" da poter poi "flashare" sulla "micro sd" della "board".  Normalmente non c'è bisogno di scaricare una "distribuzione lite" (quindi senza un "desktop enviroment" installato), in quanto la struttura gerarchica di "linux" tiene i vari servizi isolati, così nello stesso sistema operativo si possono avere più "desktop enviroment" installati contemporaneamente, con la possibilità in fase di "Log" di poter scegliere quale caricare. Ma il fatto che i due "desktop enviromet" ("pixel e XFCE") condividessero la stessa radice e che peraltro fossero entrambi basati su un motore grafico ("Xorg 11") che non è famoso per la sua affidabilità, ha portato alla scelta di cui sopra. 
Dopo il download dell'immagine del sistema operativo scelto, quest'ultimo è stato "flashato" sulla "micro sd" utilizzando l'applicazione "\href{https://etcher.balena.io/}{Balenaetcher}", mentre per fare i backup del sistema e il ripristino è stato usato "\href{https://www.tweaking4all.com/software/macosx-software/applepi-baker-v2/}{ApplePi-Baker v2}". \\
Avviato e configurato il sistema operativo dopo il primo avvio sul "RaspberryPi", si è poi proceduto all'installazione del "desktop enviroment XFCE" utilizzando questa \href{https://www.makeuseof.com/desktop-environments-you-can-run-on-a-raspberry-pi/}{guida}.\\
Una volta terminata l'installazione, le prestazioni del "RaspberryPi" erano ottime, tanto che era possibile pensare di poter lavorare direttamente sulla "board" senza passare per un collegamento in remoto. Ma quando si è provato ad installare l'applicazione "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" per il collegamento remoto si sono riscontrati dei problemi. Si è pensato di installare ugualmente un'applicazione per il controllo remoto in modo da potersi garantire delle possibilità in più durante lo sviluppo del progetto, in particolare si è pensato alla possibilità di poter condividere il "desktop" del "RaspberryPi" durante le riunioni online con il professore. La scelta di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}", ovvero un servizio per il collegamento remoto tramite "RDP" ossia il "Microsoft Remote Desktop Protocol", è stata fatta per una motivazione di praticità, in quanto in ambiente "Windows" si ha sempre avuto una grande difficoltà a collegarsi in "SSH" con Linux. Disponendo anche di macchine con "Windows" e dato che il "client RDP" è ormai disponibile per tutti i sistemi operativi si è optato per l'installazione di "XRDP" sul "Raspberry pi".\\
L'installazione di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" è avvenuta tramite "apt" e il principale problema rilevato in questa configurazione del sistema è che l'applicazione per il controllo remoto non riusciva a contattare correttamente il server grafico di "XORG 11", anche se dalla documentazione dell'applicazione si poteva leggere che il "desktop enviroment" compatibile era "XFCE".\\
A questo punto è bene spiegare quella che secondo me è stata la motivazione della problematica riscontrata. L'applicazione per il controllo remoto ha funzionato perfettamente se installata sul sistema "Rasbian" con il "desktop enviroment" di "default", ovvero "Pixel". A questo proposito si deve tenere in considerazione che "Pixel" è basato su "LXDE" e che se anche condivide la radice con "XFCE", dalla documentazione di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" non viene dato come sicuramente compatibile. Quindi date le premesse nel caso specifico di "Raspbian" il comando "apt" esegue degli script a fine installazione per rendere molte delle applicazioni scaricate come "sicuramente funzionanti" ma, nel nostro caso, l'esecuzione di questo script ha fatto in modo che le impostazioni di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" andassero a puntare ad un server che non esisteva sul sistema. A riprova di questo vi è che è stato comunque tentato di far funzionare l'applicazione grafica sull'attuale configurazione del sistema operativo e che durante "l'editing" dei file di configurazione sono stati trovati dei valori che non sembravano essere compatibili con lo stato del sistema.\\
Dopo aver effettuato le correzioni si è passati dall'applicazione che "crashava" anche durante la sola apertura, all'applicazione che era stabile e poteva funzionare, anche se per un motivo non ben chiaro veniva visualizzato un "desktop" (virtuale) che non era stato inizializzato (ovvero il numero 12, che pare essere della pila di "desktop" quello finale per "Xorg 11") con la conseguenza che dal "client" si vedeva una schermata nera. Se poi si cercava di far puntare l'applicazione all'unico "desktop" realmente inizializzato  (ovvero il numero 1, l'unico che viene inizializzato automaticamente durante l'installazione di un "desktop eviroment") l'applicazione al momento della richiesta per l'accesso remoto "crashava" direttamente.\\

\subsection{Installazione di "Raspbian" con il "desktop eviroment" di default}
\raggedright
Vedendo a questo punto che si era perso troppo tempo per far funzionare (senza garanzie di stabilità) le applicazioni nel "RaspberryPi", si decide di abbandonare la strada precedente "flashando" nella "micro sd" la versione base di "Raspbian" (sempre scaricata dal sito del produttore). La versione base si differenzia rispetto la versione "lite" per la pre-installazione di un "desktop enviroment" (chiaramente "Pixel") e per una scelta ridotta di software consigliati.\\
Il nuovo sistema operativo installato non presenta le stesse prestazioni della configurazione precedente, in particolare si notano dei rallentamenti all'avvio della board, al caricamento dei servizi e all'avvio delle applicazioni. Inoltre, ad applicazioni aperte si notano dei "glitch" grafici. Si è indagato questo problema monitorando le risorse di sistema con "\href{https://htop.dev/}{HTOP}", installato via "apt". Si scopre quindi che la "board" ha finito la memoria "RAM" ma che anche la memoria di "swap" è satura, per cui ora è ben chiara la presenza dei "glitch" grafici, che sono conseguenza della continua allocazione e deallocazione dei processi.\\
Non sapendo come aumentare la memoria di "swap", si procede nel frattempo all'installazione delle applicazioni necessarie per lo sviluppo del progetto, iniziando proprio da "\href{https://github.com/neutrinolabs/xrdp}{XRDP}". Questa volta l'applicazione per il controllo remoto funziona correttamente nonostante i continui rallentamenti per le scarse risorse della "board". Si prosegue quindi con l'installazione di "\href{https://pi-apps.io/}{Pi-Apps}", ovvero una specie di "app-store" per il "RaspberryPi" che basa l'installazione delle applicazioni su degli "script" scritti ad-hoc per la "board". In questo modo è possibile installare sul "RaspberryPi" applicazioni complesse come "\href{https://code.visualstudio.com/}{Visual Studio Code}" in maniera automatizzata. Un'applicazione in particolare che non si può installare su "RaspberryPi" se non attraverso questo sistema è il "porting" di "\href{https://desktop.github.com/}{GitHub Desktop}" molto utile per semplificare e automatizzare la gestione di una "repository".\\
Ovviamente al posto di installare "\href{https://desktop.github.com/}{GitHub Desktop}" si sarebbe potuto installare "\href{https://git-scm.com/}{Git}" via "apt" e stabilire delle macro sul terminale per automatizzare ugualmente e in un certo modo semplificare la gestione di un "repository" ma siccome in questa seconda fase d'installazione si è posto l'accento su come poter "guadagnare" tempo, è stata preferita la prima soluzione.\\
A questo punto, guardando con attenzione "\href{https://pi-apps.io/}{Pi-Apps}" si scopre che era stato inserito uno script per aumentare la memoria di "swap" del "RaspberryPi" con il passaggio dai 100mb canonici, stanziati durante l'installazione del sistema operativo, a ben 4gb. Ovviamente, questa operazione è stata fatta tenendo in considerazione che in questo modo la scheda "micro sd" era sottoposta a molto più stress, diminuendo sensibilmente la sua durata.\\
Con l'esecuzione dello "script", i "glitch" grafici sono spariti e le applicazioni hanno iniziato ad avere dei tempi di caricamento più accettabili.\\
Senza ancora aver installato la piattaforma scelta per lo sviluppo di applicazioni web, sono state fatte delle prove di utilizzo di "\href{https://code.visualstudio.com/}{Visual Studio Code}" per verificare la sua utilizzabilità. Questa applicazione era stata installata per poter usufruire dell'importante ambiente di scrittura che mette a disposizione, ma purtroppo, il "Raspberry Pi" non è in grado di reggere questa applicazione, con la conseguenza che la scrittura di codice risulta molto difficoltoso. Per questo motivo si è pensato di installare "l'editor \href{https://www.geany.org/}{Geany}" via "apt". Questo "editor" di testo non presenta le stesse caratteristiche di scrittura avanzata tipiche invece della prima applicazione, ma per il fatto che sia molto leggero, lo rende particolarmente idoneo ad essere utilizzato sulla "board".\\
A questo punto si procede con l'installazione di "\href{https://it.wikipedia.org/wiki/LAMP}{LAMP}" utilizzando una \href{https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/}{guida} trovata su internet. 

\section{Rendere il Raspberry pi raggiungibile da internet}\label{sez:Rendere il Raspberry pi raggiungibile da internet}
\raggedright
Il "RaspberryPi" doveva essere raggiungibile all'esterno della rete locale, dato che  il progetto aveva anche l'obiettivo di sperimentare la costruzione di un "home server".\\
Per prima cosa si è contattato il "service provider" di internet per richiedere l'attivazione dell'indirizzo "ip" pubblico. Quindi è stato contattato il centro di assistenza (in questo caso il centro di assistenza di "Fastweb"), interagendo tramite un "bot" di "WhatsApp" che solo dopo aver completato le procedure preliminari consente di potersi mettere in lista per ricevere una chiamata da un operatore per poter attivare l'indirizzo.\\
Dopo 4 giorni dalla telefonata, il modem si è "resettato" autonomamente, cambiando alcune sue impostazioni interne, tra cui lo stato dei vari indirizzi, facendo comparire un indirizzo "ip" pubblico. 
Inizialmente per fare delle prove di raggiungibilità, dal modem è stata aperta la porta "8080" ed è stato impostato un "redirect" all'indirizzo "ip" statico del "RaspberryPi" con ingresso sulla porta "80" in modo da poter contattare direttamente il "web server".\\
Dal lato del modem è stata aperta la porta "8080" dato che le classiche porte  per contattare i "web server" ("80" e "443") sono occupate staticamente dalla pagina di configurazione del modem stesso. Tra l'altro questo spiega per quale motivo nei modem "Fastweb" l'accesso alle impostazioni è possibile solo premendo una combinazione di tasti sul modem stesso perché è evidente che dopo l'assegnazione dell'indirizzo "ip" pubblico la pagina di configurazione del modem sarebbe esposta su internet e se quest'ultima fosse protetta solo con una "password", sarebbe solo una questione di tempo che un mal intenzionato possa accedere alle impostazioni.\\
Una volta terminate le prove di raggiungibilità è stato abilitato il protocollo "HTTPS" (autofirmando il certificato) sul server di "Apache" seguendo questa \href{https://peppe8o.com/self-signed-certificate-https-in-raspberry-pi-with-apache/}{guida}, in modo da poter lavorare fin da subito con una connessione cifrata, ovvero che non trasmettesse in "chiaro" le credenziali di accesso all'account al "web server". Finita la procedura è stato poi cambiato il "port forwarding" in modo che le richieste sulla porta "8080" del modem fossero riportate alla porta "443" del "RaspberryPi".\\
Il passo successivo è stato quello di accedere al "RaspberryPi"  da internet senza l'ausilio dell'indirizzo "ip" pubblico ma da un "nome di dominio", per questo ci si è rivolti a dei "provider" di servizi "DDNS".\\
Per prima cosa, è stato controllato a quali servizi "DDNS" ci si sarebbe potuti collegare con il modem "Fastweb". Inizialmente è stato provato ad utilizzare il servizio "DTDNS.com" (in quanto sembrava essere il più semplice da usare e che offriva gratuitamente tutte le funzionalità di base delle quali si necessitava) ma per quanto fosse incluso nella scelta dei servizi "DDNS" configurabili per il modem, non ha mai funzionato, nel senso che la configurazione del servizio nel modem dava sempre errore.\\
Dopo aver provato invano di cancellare l'account creato sul sito, si è passati ad utilizzare il servizio offerto da "changeip.com" il quale, pur essendo molto meno intuitivo del precedente, non ha dato problemi nella configurazione del servizio nel modem.\\
Per quanto riguarda la configurazione dei servizi "DDNS" nel modem "Fastweb" è bene sottolineare che la pagina di configurazione ha un  problema a gestire password e nomi lunghi, infatti dopo l'inserimento dei suddetti, il modem andava in blocco e la pagina internet di configurazione smetteva di funzionare. Quando si provava a riaccedere alla pagina di configurazione (una volta esser usciti), il modem non caricava più quest'ultima e per poter riprendere la configurazione bisognava aspettare che il modem si riavviasse autonomamente.\\


