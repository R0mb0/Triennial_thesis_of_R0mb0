\chapter{Introduzione}\label{cap:Programmazione del supporto hardware del progetto}

\section{Programmazione RaspberryPi}\label{sez:Programmazione RaspberryPi}

Come descritto nella sezione precedente, la "board" usata per il progetto è stata un "RaspberryPi 3b+", la quale chiaramente non è una "board" ormai datata, siccome era già da circa un anno che era stato rilasciato il "RaspebrryPi 4". Ragionevolmente il software disponibile per questi sistemi è stato aggiornato per adattarsi alle nuove caratteristiche e potenzialità, con la conseguenza che i modelli più vecchi non sono più idonei a supportare il software "main line" a causa delle risorse limitate rispetto ai più recenti.\\
Per questo motivo si era pensato (pur utilizzando software "main line") di cercare di risparmiare risorse provando a sostituire il "desktop eviroment" di base, installato con il sistema operativo "Raspbian". In particolare l'intento era quello di confrontare le prestazioni tra il "desktop enviroment Pixel" (basato su "LXDE") e di "XFCE".  

\subsection{Installazione del "desktop eviroment XFCE" e delle applicazioni di base}
Dal sito di "\href{https://www.raspberrypi.com/software/operating-systems/}{RaspberryPi}" è stata scaricata l'immagine del sistema operativo "Raspbian" in formato "Lite" da poter poi "flashare" sulla "micro sd" della "board".  Normalmente non c'è bisogno di scaricare una "distribuzione lite" (quindi senza un "desktop enviroment" installato), in quanto la struttura gerarchia di "linux" tiene i vari servizi isolati, per questo motivo nello stesso sistema operativo si possono avere più "desktop enviroment" installati contemporaneamente, con la possibilità in fase di "Log" di poter scegliere quale caricare. Ma il fatto che i due "desktop enviromet" ("pixel e XFCE") condividessero la stessa radice e che peraltro fossero entrambi basati su un motore grafico ("Xorg 11") che non è famoso per la sua affidabilità, ha portato alla scelta di cui sopra. 
Dopo il download della immagine del sistema operativo scelto, quest'ultimo è stato "flashato" sulla "micro sd" utilizzando l'applicazione "\href{https://etcher.balena.io/}{Balenaetcher}", mentre per fare i backup del sistema e il ripristino è stato usato "\href{https://www.tweaking4all.com/software/macosx-software/applepi-baker-v2/}{ApplePi-Baker v2}". \\
Una volta aver avviato e configurato il sistema operativo dopo il primo avvio sul "RaspberryPi", si è poi proceduto alla installazione del "desktop enviroment XFCE" utilizzando questa \href{https://www.makeuseof.com/desktop-environments-you-can-run-on-a-raspberry-pi/}{guida}.\\
Una volta terminata l'installazione, le prestazioni del "RaspberryPi" erano ottime, fino al punto che era possibile pensare di poter lavorare direttamente sulla "board" senza passare per un collegamento in remoto. Ma quando si è provato ad installare comunque l'applicazione "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" per il collegamento remoto sono iniziati a sorgere dei problemi. Si è pensato di installare ugualmente una applicazione per il controllo remoto in modo da potersi garantire delle possibilità in più durante lo sviluppo del progetto, in particolare si è pensato alla possibilità di poter condividere il "desktop" del "RaspberryPi" durante le riunioni online con il professore. La scelta di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}", ovvero un servizio per il collegamento remoto tramite "RDP" ossia il "Microsoft Remote Desktop Protocol", è stata fatta per una motivazione di praticità, in quanto in ambiente "Windows" ho sempre avuto una grande difficoltà a collegarmi in "SSH" con Linux. Poiché dispongo di anche di macchine con "Windows" e siccome comunque il "client RDP" è ormai disponibile per tutti i sistemi operativi ho optato per l'installazione di "XRDP" sul "Raspberry pi".\\
L'installazione di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" è avvenuta tramite "apt", il principale problema che è stato rilevato in questa configurazione del sistema è che l'applicazione per il controllo remoto non riusciva a contattare correttamente il server grafico di "XORG 11", anche se dalla documentazione della applicazione si poteva leggere che il "desktop eviroment" con il quale si sono riscontrati meno problemi era "XFCE".\\
A questo punto della narrazione m'interrompo un momento per spiegare quella che secondo me è la motivazione della problematica che ho riscontrato. La premessa è che l'applicazione per il controllo remoto ha funzionato perfettamente se installata sul sistema "Rasbian" con il "desktop enviroment" di "default", ovvero "Pixel". A questo proposito si deve tenere in considerazione che "Pixel" è basato du "LXDE" che pur essendo vero che condivide la radice con "XFCE", dalla documentazione di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" non viene dato come sicuramente compatibile. Allora date le premesse è che nel caso specifico di "Raspbian" il comando "apt" esegua degli script a fine installazione per rendere molte delle applicazioni scaricate come "sicuramente funzionanti", ma nel mio caso, l'esecuzione di questo script ha fatto in modo che le impostazioni di "\href{https://github.com/neutrinolabs/xrdp}{XRDP}" andassero a puntare ad un server che non esisteva sul mio sistema. A riprova di questa conclusione vi è il fatto che è stato comunque tentato di far funzionare l'applicazione grafica sulla attuale configurazione del sistema operativo, e che durante "l'editing" dei file di configurazione sono stati trovati dei valori che non sembravano poter essere compatibili con lo stato del sistema.\\
Dopo aver effettuato le correzioni si è passati dal fatto che l'applicazione "crashasse" anche durante la sola apertura, al fatto che l'applicazione era stabile e poteva funzionare, se non fosse che per un motivo che non mi è chiaro, veniva visualizzato un "desktop" (virtuale) che non era stato inizializzato (ovvero il numero 12, che mi pare essere della pila di "desktop" quello finale per "Xorg 11") con la conseguenza che dal "client" si vedeva una schermata nera. Se poi si cercava di far puntare l'applicazione all'unico "desktop" realmente inizializzato  (ovvero il numero 1, l'unico che viene inizializzato automaticamente durante l'installazione di un "desktop eviroment") l'applicazione al momento della richiesta per l'accesso remoto "crashava" direttamente.\\

\subsection{Installazione di "Raspbian" con il "desktop eviroment" di default}
Arrivato a questo punto della precedente installazione, mi rendo conto che stavo perdendo troppo tempo per far funzionare (senza garanzie di stabilità) le applicazioni nel "RaspberryPi". Per cui decido di abbandonare la strada precedente "flashando" nella "micro sd" la versione base di "raspbian" (sempre scaricata dal sito del produttore). La versione base si differenza rispetto la versione "lite" per la pre-installazione di un "desktop eviroment" (chiaramente "Pixel") e per una scelta ridotta di software consigliati.\\
Il nuovo sistema operativo installato non presenta le stesse prestazioni della configurazione precedente, in particolare si notano dei rallentamenti all'avvio della board, al caricamento dei servizi e all'avvio delle applicazioni. Inoltre, ad applicazioni aperte si notano dei "glitch" grafici. Si è indagato questo problema monitorando le risorse di sistema con \href{https://htop.dev/}{HTOP}, installato via "apt". Si scopre quindi che la "board" ha finito la memoria "RAM" ma che anche la memoria di "swap" è satura, per cui ora è ben chiara la presenza dei "glitch" grafici, che sono conseguenza della continua allocazione e deallocazione dei processi.\\
Non sapendo come aumentare la memoria di "swap", procedo nel frattempo alla installazione delle applicazioni necessarie per lo sviluppo del progetto, iniziando proprio da "\href{https://github.com/neutrinolabs/xrdp}{XRDP}". Questa volta, l'applicazione per il controllo remoto funziona correttamente, nonostante i continui rallentamenti per le scarse risorse della "board". Si prosegue quindi con l'installazione di "\href{https://pi-apps.io/}{Pi-Apps}", ovvero una specie di "app-store" per il "RaspberryPi" che basa l'installazione delle applicazioni su degli "script" scritti ad-hoc per la "board", in questo modo posso installare sul "RaspberryPi" applicazioni complesse come "\href{https://code.visualstudio.com/}{Visual Studio Code}" in maniera automatizzata. Una applicazione in particolare che non si può installare su "RaspberryPi" se non attraverso questo sistema è il "porting" di "\href{https://desktop.github.com/}{GitHub Desktop}" molto utile per semplificare e automatizzare la gestione di una "repository".\\
Ovviamente al posto di installare "\href{https://desktop.github.com/}{GitHub Desktop}" avrei potuto installare "\href{https://git-scm.com/}{Git}" via "apt" e stabilire delle macro sul terminale per ugualmente automatizzare e in un certo modo semplificare la gestione di un "repository" ma siccome in questa seconda fase d'installazione si è posto l'accento su come poter "guadagnare" tempo, è stata preferita la prima soluzione.\\
A questo punto, guardando con attenzione "\href{https://pi-apps.io/}{Pi-Apps}" si scopre che era stato inserito uno script per aumentare la memoria di "swap" del "RaspberryPi" con il passaggio dai 100mb canonici, stanziati durante l'installazione del sistema operativo, a ben 4gb per stare larghi. Ovviamente, questa operazione è stata fatta tenendo in considerazione il fatto che in questo modo la scheda "micro sd" sarà sottoposta a molto più stress, diminuendo sensibilmente la sua durata.\\
Con l'esecuzione dello "script", i "glitch" grafici sono spariti e le applicazioni hanno iniziato ad avere dei tempi di caricamento più accettabili.\\
Senza ancora aver installato la piattaforma per lo sviluppo di applicazioni web scelta, sono state delle prove di utilizzo di "\href{https://code.visualstudio.com/}{Visual Studio Code}" per verificare la sua utilizzabilità. Questa applicazione era stata installata per poter usufruire dell'importante ambiente di scrittura che mette a disposizione, ma purtroppo, il "Raspberry Pi" non è in grado di reggere questa applicazione, con la conseguenza che la scrittura di codice tramite questa risulta molto difficoltoso. Per questo motivi si è pensato di installare "l'editor \href{https://www.geany.org/}{Geany}" via "apt". Questo "editor" di testo non presenta le stesse caratteristiche di scrittura avanzata tipiche invece della prima applicazione, però il fatto che sia molto leggero, lo rende particolarmente idoneo ad essere utilizzato sulla "board".\\
A questo punto procedo con l'installazione di "\href{https://it.wikipedia.org/wiki/LAMP}{LAMP}" utilizzando una \href{https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/}{guida} trovata su internet. 

\subsection{Rendere il Raspberry pi raggiungibile da internet}